<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿åˆ‡æ°´æœ (åˆ€å…‰ä¿®å¤ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; user-select: none; }
        
        /* æ¸¸æˆèƒŒæ™¯ */
        #game-container { 
            position: relative; width: 100vw; height: 100vh; 
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); 
        }
        
        #game-canvas { display: block; width: 100%; height: 100%; cursor: none; /* éšè—é¼ æ ‡ï¼Œå®Œå…¨é æ‰‹åŠ¿ */ }
        
        /* æ‘„åƒå¤´å°çª— */
        #cam-wrapper {
            position: absolute; bottom: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid #00ffcc; border-radius: 8px;
            overflow: hidden; background: #000; z-index: 10;
            transform: scaleX(-1);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            opacity: 0.8;
        }
        #input-video { display: none; }
        #debug-canvas { width: 100%; height: 100%; object-fit: cover; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
        }
        
        #score-board {
            margin-top: 20px; font-size: 80px; color: #fff;
            text-shadow: 0 0 10px #00ffcc, 4px 4px 0px #000;
            font-weight: 800; display: none; transition: transform 0.1s;
            z-index: 5;
        }
        .score-pop { transform: scale(1.3); }
        
        #message {
            position: absolute; top: 15%;
            font-size: 24px; color: #fff; background: rgba(0, 0, 0, 0.6);
            padding: 20px 40px; border-radius: 20px; text-align: center;
            border: 2px solid #00ffcc; box-shadow: 0 0 30px rgba(0, 255, 204, 0.2);
            line-height: 1.6; z-index: 20;
            backdrop-filter: blur(5px);
        }
        .loading-text { color: #ffff00; font-weight: bold; font-size: 28px; }
        .tips { font-size: 16px; color: #ccc; margin-top: 10px; }
    </style>

    <!-- 1. Three.js -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 2. MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-layer">
        <div id="score-board">0</div>
        <div id="message">
            <div class="loading-text">âš”ï¸ æ­£åœ¨åˆå§‹åŒ–å…‰å‰‘...</div>
            <div class="tips">è¯·å…è®¸æ‘„åƒå¤´æƒé™<br>åŠ è½½å®Œæˆåï¼ŒæŒ¥åŠ¨æ‰‹æŒ‡</div>
        </div>
    </div>
    
    <div id="cam-wrapper">
        <video id="input-video" playsinline></video>
        <canvas id="debug-canvas" width="640" height="480"></canvas>
    </div>
</div>

<script>
// --- 0. å…¨å±€é…ç½® ---
const CFG = {
    trailLength: 20, // æ‹–å°¾é•¿åº¦
    trailWidth: 1.5, // æ‹–å°¾å®½åº¦
    sensitivity: 2.5 // æ‰‹åŠ¿ç§»åŠ¨çµæ•åº¦
};

// --- 1. éŸ³æ•ˆç³»ç»Ÿ ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const SoundFX = {
    play: (freq, type, dur, vol=0.1) => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.value = freq;
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + dur);
    },
    cut: () => {
        SoundFX.play(800+Math.random()*400, 'sawtooth', 0.1, 0.1);
        SoundFX.play(100, 'sine', 0.2, 0.1); // ä½éŸ³æ‰“å‡»æ„Ÿ
    },
    start: () => { SoundFX.play(440, 'sine', 0.1); setTimeout(()=>SoundFX.play(880, 'sine', 0.3), 100); },
    bad: () => SoundFX.play(150, 'square', 0.4, 0.15),
    bomb: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const b = audioCtx.createBuffer(1, 22050, 44100);
        const d = b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length);
        const s = audioCtx.createBufferSource(); s.buffer=b;
        const g = audioCtx.createGain(); g.gain.value=1;
        s.connect(g); g.connect(audioCtx.destination); s.start();
    }
};

// --- 2. Three.js åœºæ™¯ ---
const canvas = document.getElementById('game-canvas');
const scene = new THREE.Scene();
// ç¨å¾®è°ƒå¤§è¿œè£å‰ªé¢
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.z = 10; 

const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

// ç¯å…‰
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const pointLight = new THREE.PointLight(0xffffff, 1, 100);
pointLight.position.set(0, 10, 10);
scene.add(pointLight);

// --- 3. æ¸¸æˆçŠ¶æ€å˜é‡ ---
let gameState = 'MENU';
let score = 0;
// é€»è¾‘æ‰‹ä½ç½® (Z=0, ç”¨äºç¢°æ’æ£€æµ‹)
let handPos = new THREE.Vector3(0, -20, 0); 
let isHandActive = false;
let items = [];
let particles = [];
let spawnTimer = null;
let shake = 0;

// --- 4. å…³é”®ä¿®å¤ï¼šå…‰å‰‘ä¸æ‹–å°¾ç³»ç»Ÿ ---

// (A) æŒ‡å°–å…‰æ ‡ (Cursor) - è®©ä½ çŸ¥é“æ‰‹æŒ‡åœ¨å“ª
const cursorGeo = new THREE.SphereGeometry(0.3, 16, 16);
const cursorMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true, 
    opacity: 0.9 
});
const cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
// æ·»åŠ ä¸€ä¸ªå…‰æ™•
const glowGeo = new THREE.PlaneGeometry(1.5, 1.5);
// ç®€å•çš„å…‰æ™•è´´å›¾ç”Ÿæˆ
const glowCanvas = document.createElement('canvas');
glowCanvas.width=64; glowCanvas.height=64;
const gCtx = glowCanvas.getContext('2d');
const grd = gCtx.createRadialGradient(32,32,0, 32,32,32);
grd.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
grd.addColorStop(1, 'rgba(0, 255, 255, 0)');
gCtx.fillStyle = grd; gCtx.fillRect(0,0,64,64);
const glowTex = new THREE.CanvasTexture(glowCanvas);
const glowMesh = new THREE.Mesh(glowGeo, new THREE.MeshBasicMaterial({
    map: glowTex, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false
}));
cursorMesh.add(glowMesh);
scene.add(cursorMesh);

// (B) åˆ€å…‰æ‹–å°¾ (Blade Trail) - ä½¿ç”¨ç²’å­æµæ›¿ä»£ Line
const bladeParticles = [];
const bladeGeo = new THREE.PlaneGeometry(0.4, 0.4); // åˆ€å…‰ç²’å­å¤§å°
const bladeTex = glowTex; // å¤ç”¨å…‰æ™•è´´å›¾

function spawnBladeParticle(pos) {
    const mat = new THREE.MeshBasicMaterial({
        map: bladeTex,
        color: 0x00ffff, // é’è‰²åˆ€å…‰
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 0.8
    });
    const mesh = new THREE.Mesh(bladeGeo, mat);
    // è§†è§‰ä½ç½®åœ¨ Z=1ï¼Œä¿è¯è¦†ç›–åœ¨åœ°çƒä¸Šæ–¹
    mesh.position.set(pos.x, pos.y, 1); 
    // éšæœºæ—‹è½¬å¢åŠ è‡ªç„¶æ„Ÿ
    mesh.rotation.z = Math.random() * Math.PI;
    scene.add(mesh);
    
    bladeParticles.push({
        mesh: mesh,
        life: 1.0, // å­˜æ´»æ—¶é—´
        decay: 0.08 // æ¶ˆå¤±é€Ÿåº¦ (è¶Šå°æ‹–å°¾è¶Šé•¿)
    });
}

function updateBlade() {
    // 1. æ›´æ–°å…‰æ ‡ä½ç½®
    if (isHandActive) {
        cursorMesh.position.set(handPos.x, handPos.y, 1);
        cursorMesh.visible = true;
        // äº§ç”Ÿæ‹–å°¾ç²’å­
        spawnBladeParticle(handPos);
        // å¦‚æœç§»åŠ¨å¾ˆå¿«ï¼Œåœ¨ä¸Šä¸€å¸§å’Œå½“å‰å¸§ä¹‹é—´æ’å€¼è¡¥ç‚¹ï¼Œé˜²æ­¢æ–­è£‚
        // (ç®€å•ç‰ˆç•¥è¿‡æ’å€¼ï¼Œåªè¦å¸§ç‡å¤Ÿé«˜é€šå¸¸æ²¡é—®é¢˜)
    } else {
        cursorMesh.visible = false;
    }

    // 2. æ›´æ–°æ‰€æœ‰æ‹–å°¾ç²’å­
    for (let i = bladeParticles.length - 1; i >= 0; i--) {
        const p = bladeParticles[i];
        p.life -= p.decay;
        
        // ç²’å­ç¼©å°
        const scale = p.life * 1.5;
        p.mesh.scale.set(scale, scale, 1);
        p.mesh.material.opacity = p.life;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bladeParticles.splice(i, 1);
        }
    }
}

// --- 5. çˆ†ç‚¸ç²’å­ç³»ç»Ÿ (åˆ‡æ°´æœç‰¹æ•ˆ) ---
const pGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
function spawnExplosion(pos, color, count, speed=1) {
    const mat = new THREE.MeshBasicMaterial({ color: color });
    for(let i=0; i<count; i++){
        const m = new THREE.Mesh(pGeo, mat);
        m.position.copy(pos);
        scene.add(m);
        particles.push({
            mesh: m,
            vel: new THREE.Vector3((Math.random()-0.5)*speed, (Math.random()-0.5)*speed, (Math.random()-0.5)*speed),
            life: 1.0
        });
    }
}

// --- 6. ç”Ÿæˆ Emoji è´´å›¾ ---
const texCache = {};
function getSprite(emoji) {
    if(!texCache[emoji]){
        const c = document.createElement('canvas'); c.width=128; c.height=128;
        const ctx = c.getContext('2d');
        ctx.font = '95px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(emoji, 64, 70);
        texCache[emoji] = new THREE.CanvasTexture(c);
    }
    const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: texCache[emoji] }));
    s.scale.set(2, 2, 1); 
    return s;
}

// --- 7. æ¸¸æˆç‰©ä½“ç±» ---
class Item {
    constructor(type) {
        this.type = type; this.active = true;
        
        if(type==='start'){
            this.mesh = new THREE.Group();
            // åœ°çƒç½‘æ ¼
            const globe = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 16, 16), 
                new THREE.MeshBasicMaterial({color:0x00aaff, wireframe:true, transparent:true, opacity:0.5})
            );
            this.mesh.add(globe);
            // å›¾æ ‡
            const s = getSprite('ğŸŒ');
            s.scale.set(3,3,1);
            this.mesh.add(s);
            this.mesh.position.set(0, 0, 0); // æ”¾åœ¨ Z=0
            this.vel = new THREE.Vector3();
        } else {
            const char = type==='melon'?'ğŸ‰':(type==='poop'?'ğŸ’©':'ğŸ’£');
            this.mesh = getSprite(char);
            
            // æŠ›å°„é€»è¾‘
            const startX = (Math.random() - 0.5) * 10;
            this.mesh.position.set(startX, -8, 0); // ä»å±å¹•ä¸‹æ–¹ç”Ÿæˆ
            
            // å‘ä¸­å¿ƒæŠ›å°„
            const velX = -startX * 0.12 + (Math.random()-0.5); 
            const velY = 0.25 + Math.random() * 0.05;
            this.vel = new THREE.Vector3(velX, velY, 0);
        }
        scene.add(this.mesh);
    }

    update() {
        if(!this.active) return;
        
        if(this.type==='start') {
            this.mesh.rotation.y += 0.01;
            this.mesh.rotation.z += 0.005;
        } else {
            this.mesh.position.add(this.vel);
            this.vel.y -= 0.005; // é‡åŠ›
            this.mesh.rotation.z += 0.05; // æ—‹è½¬ Sprite
            if(this.mesh.position.y < -12) this.remove();
        }

        // ç¢°æ’æ£€æµ‹
        if(isHandActive) {
            // è®¡ç®—è·ç¦» (å¿½ç•¥ Z è½´å·®å¼‚ï¼Œåªçœ‹å¹³é¢æŠ•å½±)
            const dist = Math.hypot(this.mesh.position.x - handPos.x, this.mesh.position.y - handPos.y);
            // åˆ¤å®šåŠå¾„
            const hitRadius = this.type === 'start' ? 1.8 : 1.2;
            
            if(dist < hitRadius) {
                this.hit();
            }
        }
    }

    hit() {
        this.remove(); shake = 0.4;
        if(this.type==='start') { 
            SoundFX.start(); 
            spawnExplosion(this.mesh.position, 0x00aaff, 50, 2); 
            startGame(); 
        }
        else if(this.type==='melon') { 
            SoundFX.cut(); score+=10; uiScore(); 
            spawnExplosion(this.mesh.position, 0xff0000, 20); 
        }
        else if(this.type==='poop') { 
            SoundFX.bad(); score-=10; uiScore(); 
            spawnExplosion(this.mesh.position, 0x8B4513, 20); 
        }
        else if(this.type==='bomb') { 
            SoundFX.bomb(); 
            spawnExplosion(this.mesh.position, 0xffaa00, 60, 3); 
            endGame(); 
        }
    }

    remove() { this.active=false; scene.remove(this.mesh); }
}

// --- 8. UI æ§åˆ¶ ---
function uiScore() {
    const el = document.getElementById('score-board');
    el.innerText = Math.max(0, score);
    el.classList.remove('score-pop'); void el.offsetWidth; el.classList.add('score-pop');
}

function initMenu() {
    gameState='MENU'; items.forEach(i=>i.remove()); items=[];
    items.push(new Item('start'));
    
    const msg = document.getElementById('message');
    msg.style.display='block';
    msg.innerHTML = `
        <div style="font-size:32px;color:#00ffcc;font-weight:bold;">ğŸ–ï¸ å‡†å¤‡å°±ç»ª</div>
        <div style="margin:10px 0;">æŒ¥åŠ¨å…‰æ ‡åˆ‡ç¢ä¸­é—´çš„åœ°çƒ</div>
        <div class="tips">ğŸ‰ +10 | ğŸ’© -10 | ğŸ’£ ç»“æŸ</div>
    `;
    document.getElementById('score-board').style.display='none';
}

function startGame() {
    gameState='PLAYING'; score=0; uiScore();
    document.getElementById('message').style.display='none';
    document.getElementById('score-board').style.display='block';
    if(spawnTimer) clearInterval(spawnTimer);
    
    // éš¾åº¦é€’å¢é€»è¾‘
    spawnTimer = setInterval(()=>{
        if(gameState!=='PLAYING') return;
        const r = Math.random();
        // 10% ç‚¸å¼¹, 20% ç²‘ç²‘, 70% è¥¿ç“œ
        items.push(new Item(r<0.1?'bomb':(r<0.3?'poop':'melon')));
    }, 750);
}

function endGame() {
    gameState='GAMEOVER'; clearInterval(spawnTimer);
    items.forEach(i=>i.remove()); items=[];
    const msg = document.getElementById('message');
    msg.innerHTML = `<div style="color:#ff4444;font-size:48px">ğŸ’¥ æ¸¸æˆç»“æŸ</div><div>å¾—åˆ†: ${score}</div><div class="tips">3ç§’åè‡ªåŠ¨é‡å¯</div>`;
    msg.style.display='block';
    setTimeout(initMenu, 3000);
}

// --- 9. é¼ æ ‡è¾…åŠ© (Debugç”¨) ---
// ä¸ºäº†é˜²æ­¢æ‰‹åŠ¿è¯†åˆ«åœ¨æŸäº›å…‰çº¿ä¸‹å¤±çµï¼Œä¿ç•™é¼ æ ‡ç‚¹å‡»ä½œä¸ºå¤‡ç”¨
window.addEventListener('mousedown', (e) => {
    const x = (e.clientX / innerWidth) * 2 - 1;
    const y = -(e.clientY / innerHeight) * 2 + 1;
    const vec = new THREE.Vector3(x, y, 0.5);
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    const distance = -camera.position.z / dir.z; // æŠ•å½±åˆ° Z=0
    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
    
    handPos.copy(pos);
    isHandActive = true;
    setTimeout(() => { isHandActive = false; }, 100);
});

// --- 10. MediaPipe Hands è§†è§‰è¯†åˆ« ---
const video = document.getElementById('input-video');
const debugCtx = document.getElementById('debug-canvas').getContext('2d');

let hands;
try {
    hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);
} catch (e) {
    document.querySelector('.loading-text').innerText = "AI ç»„ä»¶åŠ è½½å¤±è´¥";
}

function onResults(results) {
    // ç»˜åˆ¶æ‘„åƒå¤´å°çª—
    debugCtx.save();
    debugCtx.clearRect(0, 0, 640, 480);
    debugCtx.drawImage(results.image, 0, 0, 640, 480);
    
    isHandActive = false;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const tip = landmarks[8]; // é£ŸæŒ‡å°–
        
        // åœ¨å°çª—ç»˜åˆ¶ç»¿ç‚¹
        debugCtx.fillStyle = '#00ff00';
        debugCtx.beginPath(); debugCtx.arc(tip.x*640, tip.y*480, 10, 0, 2*Math.PI); debugCtx.fill();

        // åæ ‡æ˜ å°„: [0,1] -> [-1,1] -> 3Dä¸–ç•Œåæ ‡
        // æ‘„åƒå¤´æ˜¯é•œåƒçš„ï¼Œæ‰€ä»¥ X è¦åè½¬ï¼š(1 - x)
        const ndcX = (1 - tip.x) * 2 - 1; 
        const ndcY = -(tip.y * 2 - 1);
        
        // ç®€å•çš„æŠ•å½±ä¼°ç®— (å‡è®¾ Z=0 å¹³é¢)
        // è§†å£å®½åº¦/é«˜åº¦ç³»æ•°æ ¹æ® Camera Z=10 è®¡ç®—
        const worldW = 18; // ç»éªŒå€¼
        const worldH = 12; // ç»éªŒå€¼
        
        // å¹³æ»‘æ’å€¼ (Lerp) å‡å°‘æŠ–åŠ¨
        const targetX = ndcX * worldW;
        const targetY = ndcY * worldH;
        
        handPos.lerp(new THREE.Vector3(targetX, targetY, 0), 0.5);
        isHandActive = true;
    }
    debugCtx.restore();
}

// æ‘„åƒå¤´å¯åŠ¨
async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: 640, height: 480, facingMode: 'user' } 
        });
        video.srcObject = stream;
        await new Promise(r => video.onloadedmetadata = r);
        video.play();
        
        document.querySelector('.loading-text').innerText = "âœ… ç³»ç»Ÿæ­£å¸¸";
        setTimeout(initMenu, 1000);
        processVideo();
    } catch (err) {
        document.querySelector('.loading-text').innerText = "æ‘„åƒå¤´æ— æ³•è®¿é—®";
    }
}
async function processVideo() {
    if (video.readyState === 4) await hands.send({image: video});
    requestAnimationFrame(processVideo);
}
startCamera();

// --- 11. ä¸»å¾ªç¯ ---
function loop() {
    requestAnimationFrame(loop);
    
    // å±å¹•éœ‡åŠ¨
    if(shake > 0) {
        camera.position.x = (Math.random()-0.5)*shake;
        camera.position.y = (Math.random()-0.5)*shake;
        shake *= 0.9;
    } else {
        camera.position.set(0, 0, 10);
    }

    // æ›´æ–°å…‰å‰‘å’Œæ‹–å°¾ (è¿™æ˜¯ä¿®å¤çš„å…³é”®)
    updateBlade();

    // æ›´æ–°ç‰©ä½“
    for(let i=items.length-1; i>=0; i--) { 
        items[i].update(); 
        if(!items[i].active) items.splice(i,1); 
    }
    
    // æ›´æ–°çˆ†ç‚¸ç²’å­
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.life -= 0.02;
        p.mesh.position.add(p.vel);
        p.mesh.scale.setScalar(p.life);
        if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
    }

    renderer.render(scene, camera);
}

// çª—å£è‡ªé€‚åº”
window.onresize = () => { 
    camera.aspect=innerWidth/innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(innerWidth,innerHeight); 
};

loop();

</script>
</body>
</html>