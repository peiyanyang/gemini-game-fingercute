<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿åˆ‡æ°´æœ (å›½å†…æé€Ÿç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Microsoft YaHei', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle, #2b2b2b 0%, #000000 100%); }
        
        /* 3D æ¸¸æˆç”»å¸ƒ */
        #game-canvas { display: block; width: 100%; height: 100%; }
        
        /* å³ä¸‹è§’æ‘„åƒå¤´åé¦ˆ */
        #cam-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #00ffcc;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            z-index: 10;
            transform: scaleX(-1); /* é•œåƒ */
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        #cam-video { display: none; }
        #debug-canvas { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }

        /* UI ç•Œé¢ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #score-board {
            margin-top: 30px;
            font-size: 60px;
            color: white;
            text-shadow: 0 0 20px #ff00de, 2px 2px 0px #000;
            font-weight: 800;
            display: none;
            transition: transform 0.1s;
        }
        .score-pop { transform: scale(1.5); }
        
        #message {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 28px;
            color: #fff;
            background: rgba(0, 0, 0, 0.85);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #00ffcc;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.2);
            line-height: 1.6;
        }
        .loading { color: #ffff00; }
        .tips { font-size: 16px; color: #aaa; margin-top: 10px; }
    </style>

    <!-- ä½¿ç”¨å›½å†… CDN (BootCDN & Elemecdn) -->
    <!-- MediaPipe ä¾èµ– -->
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-layer">
        <div id="score-board">0</div>
        <div id="message" class="loading">
            <div>ğŸš€ æ­£åœ¨åŠ è½½ AI æ¨¡å‹...</div>
            <div class="tips">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
        </div>
    </div>
    
    <div id="cam-wrapper">
        <video id="cam-video"></video>
        <canvas id="debug-canvas" width="640" height="480"></canvas>
    </div>
</div>

<script>
/**
 * 1. éŸ³æ•ˆç³»ç»Ÿ (Web Audio API - æ— éœ€å¤–éƒ¨æ–‡ä»¶)
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const SoundFX = {
    play: (freq, type, duration, vol=0.1) => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        // éŸ³é‡åŒ…ç»œ
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    cut: () => {
        // æ¨¡æ‹ŸæŒ¥åˆ€/åˆ‡å¼€çš„å—–å—–å£°
        SoundFX.play(600 + Math.random()*200, 'sawtooth', 0.15, 0.1);
        SoundFX.play(1000 + Math.random()*500, 'sine', 0.1, 0.05);
    },
    bomb: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const bufferSize = audioCtx.sampleRate * 0.5;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i/(bufferSize/5));
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    start: () => {
        SoundFX.play(440, 'sine', 0.1);
        setTimeout(()=> SoundFX.play(554, 'sine', 0.1), 100);
        setTimeout(()=> SoundFX.play(659, 'sine', 0.2), 200);
    },
    bad: () => SoundFX.play(100, 'sawtooth', 0.4, 0.2)
};

/**
 * 2. Three.js åœºæ™¯ä¸æ¸²æŸ“
 */
const canvas = document.getElementById('game-canvas');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 8; // ç¨å¾®æ‹‰è¿œä¸€ç‚¹

const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// ç¯å…‰
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

/**
 * 3. æ¸¸æˆæ ¸å¿ƒé€»è¾‘
 */
let gameState = 'MENU'; 
let score = 0;
let handPos = new THREE.Vector3(0, -20, 0); // åˆå§‹åœ¨å±å¹•å¤–
let isHandActive = false;
let screenShake = 0;

// --- åˆ€å…‰è½¨è¿¹ (Glowing Trail) ---
const TRAIL_LENGTH = 12;
const trailPoints = [];
const trailGeo = new THREE.BufferGeometry();
// ä½¿ç”¨å¸¦é¡¶ç‚¹çš„ Line æ— æ³•åšå®½åº¦å˜åŒ–ï¼Œè¿™é‡Œç”¨ç®€å•çš„çº¿ï¼Œé ç²’å­è¡¥è¶³ç‰¹æ•ˆ
const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 }); 
// æ³¨æ„ï¼šWindows Chrome ä¸æ”¯æŒ linewidth > 1ï¼Œæ‰€ä»¥ä¸»è¦é ç²’å­å’Œè§†è§‰æš‚ç•™
const trailMesh = new THREE.Line(trailGeo, trailMat);
// é¢„å¡«å……
for(let i=0; i<TRAIL_LENGTH; i++) trailPoints.push(new THREE.Vector3(0,-20,0));
scene.add(trailMesh);

function updateTrail(pos) {
    trailPoints.shift();
    trailPoints.push(pos.clone());
    
    // å¹³æ»‘å¤„ç†
    const points = [];
    for(let i=0; i<trailPoints.length; i++) {
        points.push(trailPoints[i]);
    }
    trailGeo.setFromPoints(points);
    
    // åˆ€å…‰ç²’å­ (åœ¨åˆ€å°–ç”Ÿæˆ)
    if(isHandActive) {
        spawnParticle(pos, 0x00ffff, 2, 0.5); 
    }
}

// --- ç²’å­ç³»ç»Ÿ (çˆ†æµ†ç‰¹æ•ˆ) ---
const particles = [];
const particleGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15); // å°æ–¹å—

function spawnParticle(pos, color, count, speedMult=1.0) {
    const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
    for(let i=0; i<count; i++) {
        const mesh = new THREE.Mesh(particleGeo, mat);
        mesh.position.copy(pos);
        // éšæœºçˆ†ç‚¸é€Ÿåº¦
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5 * speedMult,
            (Math.random() - 0.5) * 0.5 * speedMult,
            (Math.random() - 0.5) * 0.5 * speedMult
        );
        scene.add(mesh);
        particles.push({ mesh, vel, life: 1.0 });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 0.02; // å¯¿å‘½è¡°å‡
        
        p.vel.y -= 0.015; // é‡åŠ›
        p.mesh.position.add(p.vel);
        p.mesh.rotation.x += p.vel.z;
        p.mesh.rotation.y += p.vel.x;
        
        p.mesh.scale.setScalar(p.life); // å˜å°
        
        if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

// --- ç”Ÿæˆ Emoji çº¹ç† ---
const textureCache = {};
function getEmojiSprite(emoji, size=128) {
    if(textureCache[emoji]) return textureCache[emoji].clone();
    
    const cvs = document.createElement('canvas');
    cvs.width = size; cvs.height = size;
    const ctx = cvs.getContext('2d');
    ctx.font = `${size*0.8}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, size/2, size/2 + size*0.05); // å¾®è°ƒå‚ç›´å±…ä¸­
    
    const tex = new THREE.CanvasTexture(cvs);
    const mat = new THREE.SpriteMaterial({ map: tex });
    const sprite = new THREE.Sprite(mat);
    textureCache[emoji] = sprite;
    return sprite.clone();
}

// --- æ¸¸æˆç‰©ä½“ ---
class GameItem {
    constructor(type) {
        this.type = type; 
        this.active = true;
        this.radius = 1.0;
        
        if (type === 'start') {
            this.obj = new THREE.Group();
            
            // åœ°çƒç½‘æ ¼
            const g = new THREE.SphereGeometry(1, 16, 16);
            const m = new THREE.MeshPhongMaterial({ color: 0x0066ff, wireframe: true, emissive: 0x001133 });
            this.mesh = new THREE.Mesh(g, m);
            this.obj.add(this.mesh);
            
            // ğŸŒ å›¾æ ‡
            const s = getEmojiSprite('ğŸŒ');
            s.scale.set(1.5, 1.5, 1);
            this.obj.add(s);
            
            this.obj.position.set(0, 0, 0);
            this.vel = new THREE.Vector3(0,0,0);
            
        } else {
            let char = 'ğŸ‰';
            if(type === 'poop') char = 'ğŸ’©';
            if(type === 'bomb') char = 'ğŸ’£';
            
            this.obj = getEmojiSprite(char);
            this.obj.scale.set(1.8, 1.8, 1);
            
            // æŠ›å°„é€»è¾‘
            const x = (Math.random() - 0.5) * 8; // -4 åˆ° 4
            this.obj.position.set(x, -6, 0);
            
            // æŠ›ç‰©çº¿é€Ÿåº¦ï¼šXè½´å‘ä¸­å¿ƒé æ‹¢ï¼ŒYè½´å‘ä¸Š
            const speedX = -x * 0.15 + (Math.random()-0.5)*0.5;
            const speedY = 0.22 + Math.random() * 0.08;
            this.vel = new THREE.Vector3(speedX, speedY, 0);
        }
        
        scene.add(this.obj);
    }

    update() {
        if(!this.active) return;

        // æ—‹è½¬
        if(this.type === 'start') {
            this.mesh.rotation.y += 0.02;
            this.mesh.rotation.z += 0.01;
        } else {
            // ç‰©ç†è¿åŠ¨
            this.obj.position.add(this.vel);
            this.vel.y -= 0.005; // é‡åŠ›
            // è¾¹ç•Œé”€æ¯
            if(this.obj.position.y < -10) this.remove();
        }

        // åˆ‡å‰²æ£€æµ‹
        if(isHandActive) {
            const dist = this.obj.position.distanceTo(handPos);
            // ç®€å•çš„è·ç¦»åˆ¤å®šï¼Œå¦‚æœé€Ÿåº¦å¿«å¯ä»¥åŠ å°„çº¿æ£€æµ‹ï¼Œä½†è¿™é‡Œæ¯å¸§æ£€æµ‹ä¹Ÿå¤Ÿç”¨äº†
            if(dist < this.radius) {
                this.slice();
            }
        }
    }

    slice() {
        this.active = false;
        
        // è§†è§‰éœ‡åŠ¨
        screenShake = 0.3;

        if (this.type === 'start') {
            SoundFX.start();
            spawnParticle(this.obj.position, 0x0088ff, 30, 2);
            startGame();
        } else if (this.type === 'melon') {
            SoundFX.cut();
            addScore(10);
            spawnParticle(this.obj.position, 0xff0000, 20, 1.5); // çº¢è‰²æœæ±
            spawnParticle(this.obj.position, 0x00ff00, 5, 1);    // ç»¿è‰²ç“œçš®
        } else if (this.type === 'poop') {
            SoundFX.bad();
            addScore(-10);
            spawnParticle(this.obj.position, 0x8B4513, 25, 1.2); // è¤è‰²
        } else if (this.type === 'bomb') {
            SoundFX.bomb();
            spawnParticle(this.obj.position, 0xffaa00, 50, 3); // çˆ†ç‚¸ç«èŠ±
            spawnParticle(this.obj.position, 0x555555, 30, 2); // çƒŸé›¾
            endGame();
        }
        
        this.remove();
    }

    remove() {
        scene.remove(this.obj);
        this.active = false;
    }
}

let items = [];
let spawnTimer = null;

function addScore(val) {
    score += val;
    const el = document.getElementById('score-board');
    el.innerText = score;
    el.classList.remove('score-pop');
    void el.offsetWidth; // trigger reflow
    el.classList.add('score-pop');
    if(score < 0) score = 0;
}

function initMenu() {
    gameState = 'MENU';
    items.forEach(i => i.remove());
    items = [];
    items.push(new GameItem('start'));
    
    const msg = document.getElementById('message');
    msg.innerHTML = `<div>ğŸ–ï¸ ä¼¸å‡ºé£ŸæŒ‡åˆ‡ç¢åœ°çƒå¼€å§‹</div><div class="tips">ğŸ‰ +10 åˆ† | ğŸ’© -10 åˆ† | ğŸ’£ æ¸¸æˆç»“æŸ</div>`;
    msg.style.display = 'block';
    document.getElementById('score-board').style.display = 'none';
}

function startGame() {
    gameState = 'PLAYING';
    score = 0;
    document.getElementById('score-board').innerText = "0";
    document.getElementById('score-board').style.display = 'block';
    document.getElementById('message').style.display = 'none';
    
    if(spawnTimer) clearInterval(spawnTimer);
    spawnTimer = setInterval(() => {
        if(gameState !== 'PLAYING') return;
        
        const r = Math.random();
        if(r < 0.1) items.push(new GameItem('bomb'));
        else if(r < 0.3) items.push(new GameItem('poop'));
        else items.push(new GameItem('melon'));
        
    }, 900);
}

function endGame() {
    gameState = 'GAMEOVER';
    clearInterval(spawnTimer);
    
    // æ¸…é™¤æ‰€æœ‰ç‰©ä½“
    items.forEach(i => i.remove());
    items = [];

    const msg = document.getElementById('message');
    msg.innerHTML = `<div style="color:#ff3333">ğŸ’¥ æ¸¸æˆç»“æŸ ğŸ’¥</div><div style="font-size:40px;margin:20px 0">${score} åˆ†</div><div class="tips">ç¨ç­‰ç‰‡åˆ»è‡ªåŠ¨é‡ç½®</div>`;
    msg.style.display = 'block';

    setTimeout(() => {
        initMenu();
    }, 3000);
}

/**
 * 4. MediaPipe æ‰‹åŠ¿è¯†åˆ«é…ç½® (ä½¿ç”¨ Elemecdn)
 */
const videoElement = document.getElementById('cam-video');
const debugCanvas = document.getElementById('debug-canvas');
const debugCtx = debugCanvas.getContext('2d');

function onHandResults(results) {
    // ç»˜åˆ¶è°ƒè¯•ç”»é¢
    debugCtx.save();
    debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
    // ç»˜åˆ¶è§†é¢‘å¸§
    debugCtx.drawImage(results.image, 0, 0, debugCanvas.width, debugCanvas.height);
    
    isHandActive = false;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // ç»˜åˆ¶éª¨æ¶
        drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
        
        // è·å–é£ŸæŒ‡æŒ‡å°– (Index 8)
        const tip = landmarks[8];
        drawLandmarks(debugCtx, [tip], {color: '#ff00de', lineWidth: 2, radius: 5});

        // åæ ‡æ˜ å°„
        // MediaPipe (0,0 å·¦ä¸Š) -> ThreeJS (0,0 ä¸­å¿ƒ)
        // æ³¨æ„ï¼šæ‘„åƒå¤´æ˜¯é•œåƒçš„ï¼Œx éœ€è¦ç¿»è½¬é€»è¾‘
        const x = (1 - tip.x) * 2 - 1; // ä¿®æ­£é•œåƒé€»è¾‘: 1-x
        const y = -(tip.y * 2 - 1);
        
        // æŠ•å½±åˆ° z=0 å¹³é¢
        // ç®€å•è®¡ç®—ï¼šè§†å£å®½çº¦ç­‰äº z_dist * tan(fov/2) * aspect * 2
        // è¿™é‡Œç›´æ¥ç”¨ç»éªŒå€¼æ˜ å°„æ›´è·Ÿæ‰‹
        const vec = new THREE.Vector3(x * 12, y * 8, 0); // 12å’Œ8å–å†³äºæ‘„åƒæœºè·ç¦»z=8
        
        // å¹³æ»‘æ’å€¼ï¼Œå‡å°‘æŠ–åŠ¨
        handPos.lerp(vec, 0.5);
        isHandActive = true;
    }
    debugCtx.restore();
}

// åˆå§‹åŒ– MediaPipe Hands
const hands = new Hands({
    locateFile: (file) => {
        // å…³é”®ï¼šæŒ‡å®šå›½å†…é•œåƒåœ°å€åŠ è½½ wasm å’Œ tflite æ¨¡å‹
        return `https://npm.elemecdn.com/@mediapipe/hands/${file}`;
    }
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1, // 1ä¸ºä¸­ç­‰æ¨¡å‹ï¼Œé€Ÿåº¦å’Œç²¾åº¦å¹³è¡¡
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(onHandResults);

// å¯åŠ¨æ‘„åƒå¤´
const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

cameraUtils.start()
    .then(() => {
        document.querySelector('.loading').innerHTML = "âœ… å‡†å¤‡å°±ç»ª";
        setTimeout(initMenu, 1000);
    })
    .catch(err => {
        document.querySelector('.loading').innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>" + err;
    });


/**
 * 5. æ¸²æŸ“å¾ªç¯
 */
function animate() {
    requestAnimationFrame(animate);

    // å±å¹•éœ‡åŠ¨é€»è¾‘
    if(screenShake > 0) {
        camera.position.x = (Math.random() - 0.5) * screenShake;
        camera.position.y = (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9; // è¡°å‡
    } else {
        camera.position.set(0, 0, 8);
    }

    // æ›´æ–°åˆ€å…‰
    updateTrail(isHandActive ? handPos : trailPoints[trailPoints.length-1]);

    // æ›´æ–°ç‰©ä½“
    for(let i=items.length-1; i>=0; i--) {
        items[i].update();
        if(!items[i].active) items.splice(i, 1);
    }

    // æ›´æ–°ç²’å­
    updateParticles();

    renderer.render(scene, camera);
}

// è‡ªé€‚åº”çª—å£
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>