<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿åˆ‡æ°´æœ (Three.js + MediaPipe)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        
        /* 3D æ¸¸æˆç”»å¸ƒ */
        #game-canvas { display: block; width: 100%; height: 100%; }
        
        /* å³ä¸‹è§’æ‘„åƒå¤´åé¦ˆ */
        #cam-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border: 3px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            z-index: 10;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤ºç¬¦åˆç›´è§‰ */
        }
        #cam-video { display: none; } /* éšè—åŸå§‹è§†é¢‘ï¼Œåªæ˜¾ç¤ºç”»äº†éª¨éª¼çš„ Canvas */
        #debug-canvas { width: 100%; height: 100%; object-fit: cover; }

        /* UI ç•Œé¢ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #score-board {
            margin-top: 20px;
            font-size: 48px;
            color: white;
            text-shadow: 0 0 10px #ff00de;
            font-weight: bold;
            display: none;
        }
        #message {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 32px;
            color: #00ffcc;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            opacity: 0.8;
        }
        .loading { color: yellow; }
    </style>

    <!-- å¼•å…¥åº“ (CDN) -->
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-layer">
        <div id="score-board">0</div>
        <div id="message" class="loading">æ­£åœ¨åŠ è½½æ¨¡å‹ä¸æ‘„åƒå¤´...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>
    
    <div id="cam-wrapper">
        <video id="cam-video"></video>
        <canvas id="debug-canvas" width="640" height="480"></canvas>
    </div>
</div>

<script>
/**
 * ------------------------------------------------------------------
 * 1. éŸ³æ•ˆç³»ç»Ÿ (Web Audio API)
 * ------------------------------------------------------------------
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const SoundFX = {
    playTone: (freq, type, duration) => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    cut: () => SoundFX.playTone(600 + Math.random()*200, 'sawtooth', 0.1),
    bomb: () => {
        // æ¨¡æ‹Ÿçˆ†ç‚¸å™ªéŸ³
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const bufferSize = audioCtx.sampleRate * 0.5;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    bgmStart: () => SoundFX.playTone(440, 'sine', 0.5), // ç®€å•çš„å¼€å§‹éŸ³
    bad: () => SoundFX.playTone(150, 'square', 0.3)
};

/**
 * ------------------------------------------------------------------
 * 2. Three.js åœºæ™¯è®¾ç½®
 * ------------------------------------------------------------------
 */
const canvas = document.getElementById('game-canvas');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

// ç¯å…‰
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(5, 5, 5);
scene.add(pointLight);

/**
 * ------------------------------------------------------------------
 * 3. æ¸¸æˆå¯¹è±¡ä¸é€»è¾‘
 * ------------------------------------------------------------------
 */
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
let score = 0;
let handPosition = new THREE.Vector3(0, -10, 0); // æ‰‹æŒ‡ä½ç½®
let isHandDetected = false;

// --- åˆ€å…‰è½¨è¿¹ ---
const trailSize = 20;
const trailPositions = new Array(trailSize).fill(new THREE.Vector3(0, -10, 0));
const trailGeometry = new THREE.BufferGeometry();
const trailVertices = new Float32Array(trailSize * 3);
trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailVertices, 3));
const trailMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 5 });
const trailLine = new THREE.Line(trailGeometry, trailMaterial);
scene.add(trailLine);

function updateTrail(pos) {
    // ç§»åŠ¨å†å²ç‚¹
    trailPositions.pop();
    trailPositions.unshift(pos.clone());
    
    const positions = trailLine.geometry.attributes.position.array;
    for (let i = 0; i < trailSize; i++) {
        positions[i * 3] = trailPositions[i].x;
        positions[i * 3 + 1] = trailPositions[i].y;
        positions[i * 3 + 2] = trailPositions[i].z;
    }
    trailLine.geometry.attributes.position.needsUpdate = true;
}

// --- è¾…åŠ©ï¼šåˆ›å»º Emoji çº¹ç† ---
function createEmojiTexture(emoji) {
    const cvs = document.createElement('canvas');
    cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    ctx.font = '100px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, 64, 64);
    const tex = new THREE.CanvasTexture(cvs);
    return tex;
}

// --- æ¸¸æˆç‰©ä½“ç±» ---
class GameObject {
    constructor(type) {
        this.type = type; // 'start_earth', 'watermelon', 'poop', 'bomb'
        this.active = true;
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.05, // X
            0.15 + Math.random() * 0.05,  // Y (å‘ä¸Š)
            0
        );
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        
        if (type === 'start_earth') {
            const geo = new THREE.SphereGeometry(1, 16, 16);
            // ç®€å•çš„ç¨‹åºåŒ–åœ°çƒæè´¨
            const mat = new THREE.MeshPhongMaterial({ 
                color: 0x2233ff, 
                emissive: 0x112244,
                wireframe: true 
            }); 
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.set(0, 0, 0); // å›ºå®šåœ¨ä¸­é—´
            this.velocity.set(0,0,0);
            
            // åŠ ä¸€ä¸ªæ–‡å­—æ ‡ç­¾
            const spriteMap = createEmojiTexture("ğŸŒ");
            const spriteMat = new THREE.SpriteMaterial({ map: spriteMap });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(1.5, 1.5, 1);
            this.mesh.add(sprite);

        } else {
            // Emojis
            let char = '';
            if (type === 'watermelon') char = 'ğŸ‰';
            if (type === 'poop') char = 'ğŸ’©';
            if (type === 'bomb') char = 'ğŸ’£';
            
            const map = createEmojiTexture(char);
            const mat = new THREE.SpriteMaterial({ map: map });
            this.mesh = new THREE.Sprite(mat);
            this.mesh.scale.set(1.5, 1.5, 1);
            
            // åˆå§‹ä½ç½®åœ¨åº•éƒ¨
            this.mesh.position.set(
                (Math.random() - 0.5) * 6,
                -4,
                0
            );
        }
        
        scene.add(this.mesh);
    }

    update() {
        if (!this.active) return;

        if (this.type !== 'start_earth') {
            // ç‰©ç†è¿åŠ¨
            this.mesh.position.add(this.velocity);
            this.velocity.y -= 0.003; // é‡åŠ›
            this.mesh.rotation.z += this.rotationSpeed; // Spriteæ—‹è½¬æ— æ•ˆï¼Œä½†ä¿ç•™é€»è¾‘ç»™Mesh

            // è¾¹ç•Œæ£€æŸ¥
            if (this.mesh.position.y < -5) {
                this.destroy();
            }
        } else {
            this.mesh.rotation.y += 0.01;
            this.mesh.rotation.x += 0.005;
        }

        // ç¢°æ’æ£€æµ‹ (ç®€å•çš„è·ç¦»æ£€æµ‹)
        if (isHandDetected) {
            const dist = this.mesh.position.distanceTo(handPosition);
            // åœ°çƒå¤§ä¸€ç‚¹ï¼Œæ°´æœå°ä¸€ç‚¹
            const hitRadius = this.type === 'start_earth' ? 1.2 : 0.8; 
            
            if (dist < hitRadius) {
                this.onCut();
            }
        }
    }

    onCut() {
        this.active = false;
        
        if (this.type === 'start_earth') {
            SoundFX.bgmStart();
            startGame();
        } else if (this.type === 'watermelon') {
            SoundFX.cut();
            score += 10;
            updateScore();
            createParticles(this.mesh.position, 0x00ff00);
        } else if (this.type === 'poop') {
            SoundFX.bad();
            score -= 10;
            updateScore();
            createParticles(this.mesh.position, 0x964B00);
        } else if (this.type === 'bomb') {
            SoundFX.bomb();
            createParticles(this.mesh.position, 0xff0000, 50);
            gameOver();
        }
        
        this.destroy();
    }

    destroy() {
        scene.remove(this.mesh);
        // ä» objects æ•°ç»„ç§»é™¤å°†åœ¨ä¸»å¾ªç¯å¤„ç†
        this.active = false;
    }
}

let objects = [];
let spawnInterval = null;

// --- ç²’å­ç‰¹æ•ˆ ---
const particles = [];
function createParticles(pos, color, count = 10) {
    const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const mat = new THREE.MeshBasicMaterial({ color: color });
    for(let i=0; i<count; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
        scene.add(mesh);
        particles.push({
            mesh: mesh,
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5),
            life: 1.0
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.mesh.position.add(p.vel);
        p.life -= 0.02;
        p.mesh.scale.setScalar(p.life);
        if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

// --- æ¸¸æˆæµç¨‹æ§åˆ¶ ---

function initMenu() {
    gameState = 'MENU';
    document.getElementById('message').innerHTML = "ç”¨é£ŸæŒ‡åˆ‡åœ°çƒå¼€å§‹æ¸¸æˆ<br>ğŸ–ï¸";
    document.getElementById('message').style.display = 'block';
    document.getElementById('score-board').style.display = 'none';
    
    // æ¸…é™¤æ—§ç‰©ä½“
    objects.forEach(o => scene.remove(o.mesh));
    objects = [];
    
    // ç”Ÿæˆåœ°çƒ
    objects.push(new GameObject('start_earth'));
}

function startGame() {
    gameState = 'PLAYING';
    score = 0;
    updateScore();
    document.getElementById('message').style.display = 'none';
    document.getElementById('score-board').style.display = 'block';
    
    // å¼€å§‹ç”Ÿæˆæ°´æœ
    if(spawnInterval) clearInterval(spawnInterval);
    spawnInterval = setInterval(() => {
        if(gameState !== 'PLAYING') return;
        
        const rand = Math.random();
        let type = 'watermelon';
        if(rand > 0.7) type = 'poop';
        if(rand > 0.9) type = 'bomb';
        
        objects.push(new GameObject(type));
    }, 800); // æ¯0.8ç§’ç”Ÿæˆä¸€ä¸ª
}

function gameOver() {
    gameState = 'GAMEOVER';
    clearInterval(spawnInterval);
    document.getElementById('message').innerHTML = `æ¸¸æˆç»“æŸ<br>å¾—åˆ†: ${score}<br>åˆ‡å±å¹•ä»»æ„ä½ç½®é‡è¯•`;
    document.getElementById('message').style.display = 'block';
    
    // æ¸…é™¤æ‰€æœ‰ç‰©ä½“
    setTimeout(() => {
        // ç­‰å¾…1ç§’åå…è®¸é‡å¼€ï¼Œé˜²æ­¢è¯¯è§¦
        const listener = () => {
             // ç®€å•çš„é‡ç½®é€»è¾‘ï¼šåªè¦æ£€æµ‹åˆ°åˆ‡åŠ¨ä¸”æ—¶é—´è¿‡äº†ä¸€ä¼šï¼Œå°±é‡ç½®
             // è¿™é‡Œç®€åŒ–ä¸ºç‚¹å‡»æˆ–åˆ‡åŠ¨åé‡å›èœå•
             initMenu();
             // ç§»é™¤ç›‘å¬
        };
        // ç®€å•å¤„ç†ï¼šé‡å›èœå•é€»è¾‘ç”± Loop æ£€æµ‹æ‰‹æŒ‡ä½ç½®è§¦å‘é‡ç½®æœ‰ç‚¹å¤æ‚ï¼Œè¿™é‡Œç®€å•åœ°é‡ç½®çŠ¶æ€
        setTimeout(initMenu, 3000); 
    }, 100);
}

function updateScore() {
    document.getElementById('score-board').innerText = score;
}

/**
 * ------------------------------------------------------------------
 * 4. MediaPipe Hands è®¾ç½®
 * ------------------------------------------------------------------
 */
const videoElement = document.getElementById('cam-video');
const debugCanvas = document.getElementById('debug-canvas');
const debugCtx = debugCanvas.getContext('2d');

function onResults(results) {
    // ç»˜åˆ¶è°ƒè¯•ç”»é¢
    debugCtx.save();
    debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
    debugCtx.drawImage(results.image, 0, 0, debugCanvas.width, debugCanvas.height);
    
    isHandDetected = false;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // å–ç¬¬ä¸€åªæ‰‹
        const landmarks = results.multiHandLandmarks[0];
        
        // ç»˜åˆ¶éª¨éª¼
        drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
        drawLandmarks(debugCtx, landmarks, {color: '#FF0000', lineWidth: 1});

        // è·å–é£ŸæŒ‡æŒ‡å°– (Index Finger Tip: 8)
        const indexTip = landmarks[8];
        
        // æ˜ å°„åˆ° Three.js ä¸–ç•Œåæ ‡
        // MediaPipe: x (0~1, left-right), y (0~1, top-bottom)
        // Three.js (z=0å¹³é¢): x (-aspect*h/2 ~ aspect*h/2), y (-h/2 ~ h/2)
        // æˆ‘ä»¬éœ€è¦æŠŠ NDC åæ ‡è½¬æ¢åˆ° z=0 çš„å¹³é¢ä¸Š
        
        const vector = new THREE.Vector3(
            (indexTip.x * 2) - 1, // NDC x
            -(indexTip.y * 2) + 1, // NDC y
            0.5 // z (unimportant for unproject if on plane, but needed for math)
        );
        
        // ç”±äºæ‘„åƒå¤´æ˜¯é•œåƒçš„ï¼ˆCSS transform scaleX(-1)ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦åè½¬ X è¾“å…¥é€»è¾‘
        // ä½†MediaPipeè¾“å‡ºçš„åæ ‡æœ¬èº«æ˜¯åŸºäºå›¾åƒçš„ã€‚å¦‚æœæˆ‘ä»¬åœ¨CSSç¿»è½¬äº†Canvasï¼Œè§†è§‰ä¸Šæ˜¯å¯¹çš„ã€‚
        // ä¸ºäº†æ¸¸æˆé€»è¾‘ç¬¦åˆè§†è§‰ï¼ˆæ‰‹å¾€å³ç§»ï¼Œåˆ€å…‰å¾€å³ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦åè½¬ Xã€‚
        vector.x = -vector.x; 

        vector.unproject(camera);
        
        const dir = vector.sub(camera.position).normalize();
        const distance = -camera.position.z / dir.z;
        const newPos = camera.position.clone().add(dir.multiplyScalar(distance));
        
        handPosition.copy(newPos);
        isHandDetected = true;
    } 
    
    debugCtx.restore();
}

const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

cameraUtils.start()
    .then(() => {
        document.querySelector('.loading').innerText = "æ¸¸æˆå°±ç»ªï¼";
        initMenu();
    })
    .catch(err => {
        document.querySelector('.loading').innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err;
    });

/**
 * ------------------------------------------------------------------
 * 5. ä¸»å¾ªç¯
 * ------------------------------------------------------------------
 */
function animate() {
    requestAnimationFrame(animate);

    // æ›´æ–°åˆ€å…‰
    if(isHandDetected) {
        updateTrail(handPosition);
    } else {
        // å¦‚æœæ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œæ”¶ç¼©è½¨è¿¹
        updateTrail(trailPositions[trailPositions.length-1]);
    }

    // æ›´æ–°æ¸¸æˆç‰©ä½“
    for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        obj.update();
        if (!obj.active) {
            objects.splice(i, 1);
        }
    }

    // æ›´æ–°ç²’å­
    updateParticles();

    renderer.render(scene, camera);
}

// çª—å£å¤§å°è°ƒæ•´
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// å¯åŠ¨æ¸²æŸ“å¾ªç¯
animate();

</script>
</body>
</html>